A bunch of ideas related to the editor

- Try data structures out without launching the program, meaning I can design data more easily by instantiating stuff in the editor and visualizing it in order to spot better ways to organize data
- With the same visualization tools to try data structures directly in the editor, I also want to visualize data at runtime when debugging
- Custom data structures can attach some editor script to visualize the data structure in a custom way, so I can visualize a hand written tree with nodes and links, directly in the editor, when debugging or when trying structures out directly in the editor
- With the same logic, I may implement a custom versioning system that works with ast nodes instead of text characters, the visualization of the repository should also happen directly in the editor, in a dedicated map
- As well as a integrated interactive terminal, I should be able to use the language itself as scripting language instead of bash/batch
- All the code that runs at compile time or interacts with the editor (pseudo compile time) will be interpreted, and it will always be all in the custom language itself
- Functions, methods, structs etc should be pickable from a side menu (sorted alphabetically), no concept of multiple files, just all symbols merged toghether, maybe divided in different subgroups to delimit their usespace (instead of namespace)
- Functions, methods, structs etc should be visualized on the map optionally and in a "blocky" shape, meaning I can actually move them around, althought the editor will help me aligning the blocks
- There should be no concept of long scrolling text as it happens in files, this editor uses a map view, not a file view, you can have functions placed in parallel along the X axis instead of the Y axis
- Visual parallel if-then branches
- C++ full interop (with heavy caching) using clang to resolve template magic, overloading magic and all that stuff, possibly using c++ inside special blocks that can access map's symbols and export results to the map, but still keep c++ terrible semantics and rules sealed in that special block (for example, object ctor, ~ctor, copy ctor, weird operators and all similarly implicit stuff)
- Super fast compilation thanks to granular caching (recheck only the definitions that changed, the map's knows which one changed because there is no text concept here). For functions, simply check the functions that changed, put them in a changelog (so the compiler knows which one are rechecked). Cache their typed and checked bytecode. (For llvm generation, read from the changelog, regen the llvm code for those functions only). But when an interface changed, and not just the implementation, then all symbols using that interface must be added to the changelog as well. By interface i mean anything that a symbol can access directly, for example the parameters list, the return value, for functions, and fields for structs.
- Mark meta definitions as "persistent" or "dynamic" (or similar names) that basically tells the map engine to reexecute them every time they are used/instantiated (even if used with same parameters of a previous use) or just cache their result for the same parameters. Dynamic meta symbols can access to caller context and meta stuff
- unit testing codepath coverage
- implement a core/base isolation mechanism for code. Core can't allocate memory and doesn't work directly on data but rather on inputs that behave in a required way. The base can provide a canonical data layout and initialization/deinitialization
- the codewire should be of different color if the branch stops the execution with an early return/continue or a break